#! /bin/bash

set -e

readonly EXEC_NAME=$(basename $0)
readonly VERSION=1


show_help()
{
  cat << EOF
$EXEC_NAME version $VERSION

Usage:
 $EXEC_NAME <class_base>

Reads the output of the \`repl\` command and groups the data objects that failed
to replicate into different files based on the error that occurred.

Parameters:
 <class_base>  the common basename of the files that hold the groups of data
               objects

Summary:

The program reads the output of the \`repl\` command from standard in. It groups
the data objects that failed to replicate into different files based on the
error that occurred. Here's a breakdown of what each output file holds.

 <class_base>.invalid_types  holds the paths to data objects that caused \`irepl\`
 to generate "invalid repl objType 0" errors.

 <class_base>.src_path_errors holds the paths to data objects that have paths
 that cause \`irepl\` problems.

 <class_base>.short_file holds the paths to data objects having sizes larger
 than their respective physical files' sizes.

 <class_base>.connection_reset holds the paths to data objects where the
 connections were reset during the replication.

 <class_base>.chksum_mismatches holds the paths to data objects with checksums
 that differ from the checksums of their respective physical files.

 <class_base>.missing_file holds the paths to data objects that are missing
 their physical files.

<class_base>.unclassified_repl_errors holds the log messages for replication
related errors that couldn't be classified.

<class_base>.unclassified_errors holds the full log messages for errors that
couldn't be classified at all.
EOF
}


if [ "$#" -lt 1 ]
then
  show_help >&2
  exit 1
fi

readonly LOG_BASE="$1"


lsl()
{
  local obj="$1"

  while ! size=$(ils -l "$obj" | awk '{ print $4 }')
  do
    sleep 1
  done

  printf '%d %s\n' "$size" "$obj"
}
export -f lsl


split_out_class()
{
  local errorsFile="$1"
  local classifier="$2"
  local substitution="$3"
  local classFile="$4"

  local errors=$(cat "$errorsFile")
  local classifiedErrors=$(sed --quiet "/$classifier/p" <<< "$errors")

  if [ -n "$classifiedErrors" ]
  then
    comm -2 -3 <(echo "$errors") <(echo "$classifiedErrors") > "$errorsFile"
    sed "s/$classifier/$substitution/" <<< "$classifiedErrors" > "$classFile"
    wc --lines <<< "$classifiedErrors"
  else
    printf '0'
  fi
}


readonly ErrorsFile=$(mktemp)
readonly ReplErrorsFile=$(mktemp)

touch "$ErrorsFile" "$ReplErrorsFile"

sed --quiet 's/.*ERROR: \([^\[].*$\)/\1/p' | sort > "$ErrorsFile"

readonly ErrCnt=$(cat "$ErrorsFile" | wc --lines)
readonly CntWid=${#ErrCnt}

printf '%*d errors\n' "$CntWid" "$ErrCnt"

readonly ITCnt=$(split_out_class "$ErrorsFile" \
                                 '^replUtil: invalid repl objType 0 for ' \
                                 '' \
                                 "$LOG_BASE".invalid_types)
printf '%*d invalid object types\n' "$CntWid" "$ITCnt"

readonly SPECnt=$(split_out_class "$ErrorsFile" \
                                  '^replUtil: srcPath \(.*\) does not exist$' \
                                  '\1' \
                                  "$LOG_BASE".src_path_errors)
printf '%*d source path errors\n' "$CntWid" "$SPECnt"

readonly RCnt=$(split_out_class "$ErrorsFile" '^replUtil: repl error for ' '' "$ReplErrorsFile")
printf '%*d replication errors\n' "$CntWid" "$RCnt"

readonly ReplErrors=$(cat "$ReplErrorsFile")
sort <<< "$ReplErrors" > "$ReplErrorsFile"

readonly SCLECnt=$(split_out_class "$ReplErrorsFile" \
                                   ', status = -27000 status = -27000 SYS_COPY_LEN_ERR$' \
                                   '' \
                                   "$LOG_BASE".short_file)
printf '%*d short files\n' "$CntWid" "$SCLECnt"

readonly CRBPCnt=$(split_out_class \
  "$ReplErrorsFile" \
  ', status = -116104 status = -116104 SYS_SOCK_READ_ERR, Connection reset by peer$' \
  '' \
  "$LOG_BASE".connection_reset)
printf '%*d connections reset\n' "$CntWid" "$CRBPCnt"

readonly UCMCnt=$(split_out_class "$ReplErrorsFile" \
                                  ', status = -314000 status = -314000 USER_CHKSUM_MISMATCH$' \
                                  '' \
                                  "$LOG_BASE".chksum_mismatches)
printf '%*d checksum mismatches\n' "$CntWid" "$UCMCnt"

readonly UFOECnt=$(split_out_class \
  "$ReplErrorsFile" \
  ', status = -510002 status = -510002 UNIX_FILE_OPEN_ERR, No such file or directory$' \
  '' \
  "$LOG_BASE".missing_file)
printf '%*d file open errors\n' "$CntWid" "$UFOECnt"

printf '%*d unclassified replication errors\n' "$CntWid" $(cat "$ReplErrorsFile" | wc --lines)

if [ -s "$ReplErrorsFile" ]
then
  mv "$ReplErrorsFile" "$LOG_BASE".unclassified_repl_errors
fi

printf '%*d unclassified errors\n' "$CntWid" $(cat "$ErrorsFile" | wc --lines)

if [ -s "$ErrorsFile" ]
then
  mv "$ErrorsFile" "$LOG_BASE".unclassified_errors
fi

rm --force "$ErrorsFile" "$ReplErrorsFile"
