#!/bin/bash

readonly ExecName=$(basename "$0")
readonly Version=1


show_help()
{
  cat << EOF

$ExecName version $Version

Usage:
 $ExecName [options] <class_base>

Reads the output of the \`repl\` command and groups the data objects that failed
to replicate into different files based on the error that occurred.

Parameters:
 <class_base>  the common basename of the files that hold the groups of data
               objects

Options:
 -h, --help     show help and exit
 -v, --version  show verion and exit

Summary:

The program reads the output of the \`repl\` command from standard in. It groups
the data objects that failed to replicate into different files based on the
error that occurred. Here's a breakdown of what each output file holds.

 <class_base>.invalid_types  holds the paths to data objects that caused \`irepl\`
 to generate "invalid repl objType 0" errors.

 <class_base>.src_path_errors holds the paths to data objects that have paths
 that cause \`irepl\` problems.

<class_base>.broken_conn holds the paths to data object where the connection to
the IES was broken.

 <class_base>.short_file holds the paths to data objects having sizes larger
 than their respective physical files' sizes.

 <class_base>.connection_reset holds the paths to data objects where the
 connections were reset during the replication.

 <class_base>.chksum_mismatches holds the paths to data objects with checksums
 that differ from the checksums of their respective physical files.

 <class_base>.missing_file holds the paths to data objects that are missing
 their physical files.

<class_base>.unclassified_repl_errors holds the log messages for replication
related errors that couldn't be classified.

<class_base>.unclassified_errors holds the full log messages for errors that
couldn't be classified at all.
EOF
}


main()
{
  local opts
  if ! opts=$(getopt --name "$ExecName" --options hv --longoptions help,version -- "$@")
  then
    exit_with_help
  fi

  eval set -- "$opts"

  while true
  do
    case "$1" in
      -h|--help)
        show_help
        exit 0
        ;;
      -v|--version)
        show_version
        exit 0
        ;;
      --)
        shift
        break
        ;;
      *)
        exit_with_help
        ;;
    esac
  done

  if [ "$#" -lt 1 ]
  then
    exit_with_help
  fi

  local logBase="$1"

  classify "$logBase"
}


classify()
{
  local logBase="$1"

  local errorsFile
  errorsFile=$(mktemp)

  local replErrorsFile
  replErrorsFile=$(mktemp)

  # shellcheck disable=SC2064
  trap "rm --force '$errorsFile' '$replErrorsFile'" EXIT

  sed --quiet 's/.*ERROR: \([^\[].*$\)/\1/p' \
    | sed '/connectToRhost: readVersion to data.cyverse.org failed, msg=/d' \
    | sort > "$errorsFile"

  local errCnt
  errCnt=$(wc --lines < "$errorsFile")

  local iTCnt
  iTCnt=$(split_out_class "$errorsFile" \
                          '^replUtil: invalid repl objType 0 for ' \
                          '' \
                          "$logBase".invalid_types)

  local sPECnt
  sPECnt=$(split_out_class "$errorsFile" \
                           '^replUtil: srcPath \(.*\) does not exist$' \
                           '\1' \
                           "$logBase".src_path_errors)

  split_out_class "$errorsFile" '^replUtil: repl error for ' '' "$replErrorsFile" > /dev/null
  sort --output "$replErrorsFile" "$replErrorsFile"

  local sHRLCnt
  sHRLCnt=$(split_out_repl_class "$replErrorsFile" \
                                 -4000 \
                                 SYS_HEADER_READ_LEN_ERR \
                                 "$logBase".broken_conn)

  local sCLECnt
  sCLECnt=$(split_out_repl_class "$replErrorsFile" \
                                 -27000 \
                                 SYS_COPY_LEN_ERR \
                                 "$logBase".short_file)

  local cRBPCnt
  cRBPCnt=$(split_out_repl_class "$replErrorsFile" \
                                 -116104 \
                                 'SYS_SOCK_READ_ERR, Connection reset by peer' \
                                 "$logBase".connection_reset)

  local uCMCnt
  uCMCnt=$(split_out_repl_class "$replErrorsFile" \
                                -314000 \
                                USER_CHKSUM_MISMATCH \
                                "$logBase".chksum_mismatches)

  local uFOECnt
  uFOECnt=$(split_out_repl_class "$replErrorsFile" \
                                 -510002 \
                                 'UNIX_FILE_OPEN_ERR, No such file or directory' \
                                 "$logBase".missing_file)

  local unclassifiedReplErrCnt
  unclassifiedReplErrCnt=$(wc --lines < "$replErrorsFile")

  if [ "$unclassifiedReplErrCnt" -gt 0 ]
  then
    mv "$replErrorsFile" "$logBase".unclassified_repl_errors
  fi

  local unclassifiedErrCnt
  unclassifiedErrCnt=$(wc --lines < "$errorsFile")

  if [ "$unclassifiedErrCnt" -gt 0 ]
  then
    mv "$errorsFile" "$logBase".unclassified_errors
  fi

  local cntWid=${#errCnt}
  printf '%*d errors\n' "$cntWid" "$errCnt"
  printf '%*d invalid object types\n' "$cntWid" "$iTCnt"
  printf '%*d source path errors\n' "$cntWid" "$sPECnt"
  printf '%*d broken connections\n' "$cntWid" "$sHRLCnt"
  printf '%*d short files\n' "$cntWid" "$sCLECnt"
  printf '%*d connections reset\n' "$cntWid" "$cRBPCnt"
  printf '%*d checksum mismatches\n' "$cntWid" "$uCMCnt"
  printf '%*d file open errors\n' "$cntWid" "$uFOECnt"
  printf '%*d unclassified replication errors\n' "$cntWid" "$unclassifiedReplErrCnt"
  printf '%*d unclassified errors\n' "$cntWid" "$unclassifiedErrCnt"
}


exit_with_help()
{
  show_help >&2
  exit 1
}


show_version()
{
  printf '%s\n' "$Version"
}


split_out_class()
{
  local errorsFile="$1"
  local classifier="$2"
  local substitution="$3"
  local classFile="$4"

  local errors
  errors=$(cat "$errorsFile")

  local classifiedErrors
  classifiedErrors=$(sed --quiet "/$classifier/p" <<< "$errors")

  if [ -n "$classifiedErrors" ]
  then
    comm -2 -3 <(echo "$errors") <(echo "$classifiedErrors") > "$errorsFile"
    sed "s/$classifier/$substitution/" <<< "$classifiedErrors" > "$classFile"
    wc --lines <<< "$classifiedErrors"
  else
    printf '0'
  fi
}


split_out_repl_class()
{
  local errorsFile="$1"
  local status="$2"
  local error="$3"
  local classFile="$4"

  split_out_class "$errorsFile" ", status = $status status = $status $error\$" '' "$classFile"
}


set -e
main "$@"
